<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[asciinema之-linux系统下屏幕分享的一种思路]]></title>
    <url>%2Ftech%2Fasciinema-share-screen%2F</url>
    <content type="text"><![CDATA[借助asciinema 实现linux系统下的屏幕分享占坑，待补充 demo1 12345# viewing terminal (hostname: node123)nc -l localhost 9999# recording terminalasciinema rec --raw &gt;(nc node123 9999) 参考：linux nc命令 - CSDN博客 demo2 123456# recording terminalmkfifo /tmp/demo.pipeasciinema rec --raw /tmp/demo.pipe# viewing terminalssh root@install_demo cat ~/demo.pipe]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>asciinema</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos常用环境安装]]></title>
    <url>%2Ftech%2Fcentos%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装nodejs 安装docker (docker-ce) 安装nginx 安装nodejs 参考：https://segmentfault.com/a/1190000007124759nodejs 官网：https://nodejs.org/en/download/package-manager/#enterprise-linux-and-fedoracurl --silent --location https://rpm.nodesource.com/setup_8.x | bash -yum -y install nodejs 安装cnpm，淘宝npm工具，提高npm下载包的速度 cnpm：https://npm.taobao.org/ npm install -g cnpm --registry=https://registry.npm.taobao.org 安装docker (docker-ce) 官方文档：https://docs.docker.com/install/linux/docker-ce/centos/参考：http://www.runoob.com/docker/centos-docker-install.html step1:Docker 要求 CentOS 系统的内核版本高于 3.10uname -r step2:移除旧版本 12345678910yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine step3: 安装一些必要的系统工具 123yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 step4: 添加软件源信息，这里使用aliyun的。 官方源：https://download.docker.com/linux/centos/docker-ce.repoyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repostep5:更新 yum 缓存yum makecache faststep6:安装 Docker-ceyum -y install docker-cestep7:启动 Docker 后台服务systemctl start dockerstep8:测试运行 hello-worlddocker run hello-world 安装 docker-compose 官方文档：https://docs.docker.com/compose/install/step1:注意这里的版本号，最新版请从这里获取Compose repository release page on GitHubcurl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-composestep2:添加可执行权限chmod +x /usr/local/bin/docker-compose docker-compose --version step3: [可选] 安装 命令行提示Command-line completion 使用国内docker仓库源 针对Docker客户端版本大于 1.10.0 的用户您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器(没有这个文件可以创建)从这个地址获取aliyun专属源地址:https://cr.console.aliyun.com/cn-hangzhou/mirrors 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://****.mirror.aliyuncs.com","https://registry.docker-cn.com","https://hub-mirror.c.163.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 安装nginx参考：https://www.jianshu.com/p/1cad13e57c43 step1:添加CentOS 7 EPEL 仓库yum install epel-releasestep2:安装Nginxyum install nginx]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker之路]]></title>
    <url>%2Fcode%2Fdocker%2Fdocker%2F</url>
    <content type="text"><![CDATA[相关文章docker之路——数据卷轴 拾记利用docker以及overlayfs文件系统创建沙盒&emsp;&emsp;ClassicOldSong/shadow,&emsp;&emsp;相关学习资料：overlay fs挂载及操作测试]]></content>
      <categories>
        <category>road</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker之路——数据卷轴]]></title>
    <url>%2Fcode%2Fdocker%2Fdocker-volume%2F</url>
    <content type="text"><![CDATA[参考 是什么 使用 挂载卷轴 删除卷轴 使用卷轴 参考理解Docker（8）：Docker 存储之卷（Volume） - SammyLiu - 博客园Docker容器学习梳理–Volume数据卷使用 - 散尽浮华 - 博客园 关于文件覆盖Docker数据持久之volume和bind mount - CSDN博客 官方文档-docker volume create 是什么在不使用数据卷轴的情况下，docker容器内的数据只存在于其生命周期内，且容器外部以及其他容器都无法访问，容器一旦删除数据也丢失了（除非commit一个新的镜像），因此会有散需求需要满足：一是 容器之间共享数据，二是容器内数据的持久化，三是容器共享宿主机数据。为了解决这三个问题所以有了数据卷轴的概念，在下文的使用中的使用卷轴中会说明如何解决这两个问题。 使用有两种使用方式，一个是docker run命令的-v参数，一个是dockerfile文件中的VOLUMEE命令 1234$ docker run --help-v, --volume list Bind mount a volume --volume-driver string Optional volume driver for the container --volumes-from list Mount volumes from the specified container(s) 挂载卷轴-v 方式挂载 -v [host-dir]:container-dir:[rw|wo] 如果指定host-dir,那么就会挂载指定的目录到容器中的目录上，并且会覆盖容器中指定目录的内容。如果不指定host-dir,那么会在系统的/var/lib/docker/volumes目录下生成一个目录挂载到容器内。可以通过docker inspect container-id来查看挂载情况 VOLUME方式挂载 在编写dockerfile文件时可以通过VOLUME dir的方式去挂载一个卷轴，这种方式与使用-v但是不指定host-dir是相同的 删除卷轴Volume只有在下列情况下才能被自动删除： 该容器是用docker rm －v命令来删除的（-v是必不可少的）。 docker run中使用了--rm参数 即使用以上两种命令，也只能删除没有容器连接的Volume。连接到用户指定主机目录的Volume永远不会被docker删除。即通过-v host-dir:container-dir明确指定主机目录的情况下，是不会删除主机上的文件的如果你没有使用上面两种方式去删除卷轴，那么通过docker volume COMMAND将可以删除僵尸卷轴 docker volume rm VOLUME [VOLUME...]删除指定的卷轴docker volume prune 清理所有不使用的卷轴 1234567891011$ docker volume --helpUsage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes 正如前面所说使用-v host-dir:container-dir指定的卷轴不会被删除，而且也不会出现在volume卷轴管理中，即通过docker volume ls命令是看不到这种方式创造的卷轴的 docker volume命令是在后来的版本中引入的新功能，它除了可以管理所有的卷轴外（除了明确指定主机目录的卷轴），还可以独立的去创建一个卷轴，这样可以方便的在多个容器之间共享卷轴 使用卷轴卷轴的目的是为了解决前文提出的三个问题，那么我们这里一一说明 数据持久化以及共享宿主机数据场景 我们通过-v host-dir:container-dir的方式将主机上的一个目录映射到容器内，这样对container-dir目录的所有操作就是对主机host-dir目录的操作，容器删除后该目录的数据仍然存在。这样便解决了数据持久化问题，以及宿主机和容器共享数据问题。 容器之间共享数据场景 docker run命令中可以通过--volumes-from参数来共享其他容器或卷轴的数据 一种方式是docker run --volumes-from container-id指定一个容器可以共享该容器中创建的卷轴，这里只是共享指定容器中创建的数据卷轴而不是共享容器的数据（目标容器运行与否无关）. 还有一种更优雅的方式则是通过docker volume命令 123456#https://docs.docker.com/engine/reference/commandline/volume_create/#extended-description$ docker volume create hellohello$ docker run -d -v hello:/world busybox ls /world ⚠️通过docker volime命令创建的卷轴在删除容器时即使加了-v参数(docker rm -v container-id)也不会删除卷轴]]></content>
      <categories>
        <category>road</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js脚本混淆加密的神奇方法-把JavaScript 代码转为[]()!+字符-把 JavaScript 代码转为颜文字]]></title>
    <url>%2Ftech%2Fjsencode%2F</url>
    <content type="text"><![CDATA[一个“神奇”的工具：把 JavaScript 代码转为 ()[]{}!+ 字符 将js转换为 !+ 6个字符JSFuck - Write any JavaScript with 6 Characters: !+ 将js转换为颜文字aaencode - Encode any JavaScript program to Japanese style emoticons (^_^) 将js转换为只有符号的字符串jjencode - Encode any JavaScript program using only symbols 解密方法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 示例 1234567&lt;a href="javascript:test()"&gt;eval&lt;/a&gt;&lt;script&gt;function test()&#123;ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');&#125;&lt;/script&gt; 123&lt;a href="javascript:eval( (![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])" id="eval" target="_blank"&gt;eval&lt;/a&gt;]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack学习]]></title>
    <url>%2Fcode%2Fwebpack%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[webpack学习中遇到的问题 webpack是什么 遇到的问题 踩坑 技巧 ProvidePlugin插件 懒加载 开发环境和线上环境的配置文件分离 命令行传入参数 external 外部扩展 tree shaking 不起作用 参考 webpack是什么webpack是一个JavaScript应用的静态模块打包器，除了会把通过import导入的模块打包成一个或多个bundle，还可以打包资源文件等等。借由插件还可以实现更多的功能，比如优化压缩代码、定义环境变量等等。 webpack会通过一个依赖关系图将应用程序所需的模块打包。 依赖关系图webpack从命令行或配置文件中定义的入口起点开始，递归一个依赖图，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载 webpack 的配置文件(webpack.config.js)，是导出一个对象的 JavaScript 文件。通过该配置文件来实现各种打包参数的配置。 通过webpack与npm的包管理，我们可以形成一套更加标准化的前端开发流程。 遇到的问题 踩坑webpack导致控制台不能获取变量webpack打包会将全局变量封装到闭包内，因此访问不到的。可以将变量绑定到window对象。 12345678window.vm= new Vue(&#123; data: &#123; count: 0, name: '全局名称' &#125;&#125;)window['testVar']='testValue'//在浏览器控制台只要 输入 `vm`、`testVar` 既可以拿到对象 技巧ProvidePlugin插件ProvidePlugin | webpack 中文网webpack.ProvidePlugin插件：不必import或require模块， 当调用的变量不存在时便会从模块加载。 注意这里不是懒加载，不是在调用的时候才加载，而是打包的时候便把模块引入了。该插件只是用于省去每个地方都要写一遍import和require这件事。如果想要实现懒加载请查看懒加载 | webpack 中文网 示例 1234plugins: [ new webpack.ProvidePlugin(&#123; globalModule: ['./globalModule.js'], &#125;)] CommonJs中的使用 globalModule.js12345678910111213console.log("globalModule loaded")// commonjs中的默认导出写法1module.exports = "globalModule";// commonjs中的默认导出写法2module.exports = function()&#123; return "globalModule" &#125;;// es2015/es6中的默认导出写法export default function () &#123; return "globalModule";&#125; index.js123456//调用代码//直接调用而无需 require或者 import// commonjs中调用默认导出console.log(globalModule())// es2015/es6中调用默认导出console.log(globalModule.default()) 对于 ES6/ES2015 模块的 default export，你必须显示指定模块的 default 属性module.default。JS - CommonJS、ES2015、AMD、CMD模块规范对比与介绍（附样例） 懒加载懒加载 | webpack 中文网通过import方式导入模块存在的一个问题是，可能导入的模块只在一些特定的场景下才会使用，而有些时候并不会用到，如果直接import的方式（import module from &#39;./module&#39;）会导致代码被执行，为了优化网页我们对此应该采取懒加载的方式。 示例 lazyModule.js12345console.log('loaded lazyModule');export default () =&gt; &#123; console.log('print hello_wolrd');&#125; index.js12345//懒加载，不要事先import而是在调用的地方importimport('./lazyModule.js').then(module =&gt; &#123; var print = module.default; print() &#125;) 懒加载的import只会执行一次，通过示例可以看到：示例中的import(&#39;./lazyModule.js&#39;)....代码即使被多次重复执行，lazyModule.js文件中的console.log(&#39;loaded lazyModule&#39;);也只会在控制台打印一次 开发环境和线上环境的配置文件分离前端开发中没有maven这样的工具可以通过profile来实现不同的环境使用不同的配置文件，但是可以借助webapck的环境变量来实现。 使用webpack-merge可以实现DRY原则（不重复原则，提取公共代码），借助该函数可以把webpack.config.js拆分为多个，也可以把环境变量等拆分为不同的环境。 使用webpack.DefinePlugin插件可以实现定义全局变量。注意，因为DefinePlugin这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。参考DefinePlugin 在代码中可以直接调用process.env的值以及 webpack.DefinePlugin 中定义的变量。变量是在打包时通过做文本替换来实现的，打包后就是直接使用变量值来呈现了。 目录结构12345678910webpack-demo|- package.json|- /src |- index.js|- webpack.common.js|- webpack.dev.js|- webpack.prod.js|- /config |- dev.env.js |- prod.env.js webpack.dev.js123456789101112const merge = require('webpack-merge');const common = require('./webpack.common.js');const webpack = require('webpack');module.exports = merge(common, &#123; plugins: [ new webpack.DefinePlugin(&#123; //引入变量 'my.env': require('./config/dev.env.js') &#125;) ]&#125;); dev.env.js12345678'use strict'const merge = require('webpack-merge')const prodEnv = require('./config/prod.env')module.exports = merge(prodEnv, &#123; //这里使用单引号加双引号才能表示字符串 ENV_NAME: '"this is env"'&#125;) index.js123//在代码中可以直接调用process.env的值以及 webpack.DefinePlugin 中定义的变量console.log('process.env.ENV_NAME:' process.env.ENV_NAME);console.log('my.env.NODE_ENV:' my.env.NODE_ENV); 经过以上配置后，在调用webpack时指定config文件既可以区分不同的环境npx webpack --config webpack.dev.js。通过配置npm的package.json中的脚本可以简化这一步骤 package.json123456&#123;"scripts": &#123; "start": "webpack-dev-server --open --config webpack.dev.js", "build": "webpack --config webpack.prod.js" &#125;&#125; 这样配置之后，运行npm start则是启动dev环境的web服务。运行npm run build则是生产线上环境 命令行传入参数如果需要使用命令行传入env参数，那么webpack.dev.js需要做一些修改以接收参数,必须将 module.exports 转换成一个函数.参考webpack-使用环境变量调用的时候通过设置--env可以使你根据需要，传入尽可能多的环境变量npx webpack --config webpack.dev.js --display-modules --env.NODE_ENV=&#39;&quot;传入一个参数&quot;&#39; --progress webpack.dev.js1234567891011121314151617181920212223242526272829const merge = require('webpack-merge');const common = require('./webpack.common.js');const webpack = require('webpack');module.exports = env =&gt; merge(common, &#123; plugins: [ new webpack.DefinePlugin(&#123; //引入变量 'process.env': env, 'my.env': require('./config/dev.env.js') &#125;) ]&#125;);//#######//以下为不使用箭头函数的写法module.exports = function (env) &#123; console.log(env); return merge(common, &#123; plugins: [ new webpack.DefinePlugin(&#123; //引入变量 'process.env': env, 'my.env': require('./config/dev.env.js') &#125;) ] &#125; )&#125;; external 外部扩展externals 配置 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖。例如 我们开发了一个自己的库，里面引用了lodash这个包，经过webpack打包的时候，发现如果把这个lodash包打入进去，打包文件就会非常大。那么我们就可以externals的方式引入。也就是说，自己的库本身不打包这个lodash，需要用户环境提供。externals属性是一个由key-value组成的对象，key值 就是import语句的模块名，如属性名称是 jquery，表示应该排除 import $ from &#39;jquery&#39; 中的 jquery 模块。value值则是模块导出的变量。参考在.vue文件中引入第三方非NPM模块,webpack externals 深入理解 - 不长写的日志 - SegmentFault 思否 例如 js中导入lodash模块import _ from &#39;lodash&#39;，那么对应的 externals写法是 externals: { lodash: &#39;_&#39; } tree shaking 不起作用在跟着官方demo学习中tree shaking 没有起作用。原因是本应该删除不用的导出的js文件在webpack.config.js的entry中作为入口配置了，因此没有处理。 tree shaking 的意思是移除未被引用的代码。在webpack中想要起作用的条件是： 使用 ES2015 模块语法（即 import 和 export）。 在项目 package.json 文件中，添加一个 “sideEffects” 入口。 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。 webpack官方指南www.webpackjs.com/guides/tree-shaking/#结论 对于第二条“sideEffects”入口还没完全研究明白，理解上大概是说通过import引入的模块，可以在模块的package.json中配置sideEffects来控制副作用，换言之 这个参数是加在通过npm安装的模块的package.json文件中。可以查看官方demo 官方提供了sideEffects属性，通过将其设置为false，可以主动标识该类库中的文件只执行简单输出，并没有执行其他操作，可以放心shaking。除了可以减小bundle文件的体积，同时也能够提升打包速度。为了检查side effects，Webpack需要在打包的时候将所有的文件执行一遍。而在设置sideEffects之后，则可以跳过执行那些未被引用的文件，毕竟已经明确标识了“我是平民”。因此对于一些我们自己开发的库，设置sideEffects为false大有裨益 Webpack4进阶www.colabug.com/2641390.html 对于第三条引入压缩工具只要在webpack.config.js配置文件中添加mode: &quot;production&quot;将模式设置为生产环境便会自动引入UglifyJSPlugin。也可以在命令行接口中使用 --optimize-minimize 标记，来使用 UglifyJSPlugin 另外webpack4中，对mode做了调整。mode:&quot;development&quot;时,将不进行tree-shaking和Scope hoisting，在使用production时才会进行这些操作。不设置mode默认为development 参考Vue2 VueRouter2 webpack 构建项目实战（一）准备工作 - CSDN博客webpack学习中遇到的坑 - 糊里糊涂撸代码 - SegmentFault 思否]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域请求问题]]></title>
    <url>%2Fcode%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景浏览器的同源策略与跨域两个页面地址中的协议、域名和端口号一致，则表示同源。 同源策略的限制： 存储在浏览器中的数据，如localStroage、Cooke和IndexedDB不能通过脚本跨域访问 不能通过脚本操作不同域下的DOM 不能通过ajax请求不同域的数据 何为ajax请求AJAX只是一种技术，不是某种具体的东西。不同的浏览器有自己实现AJAX的组件。AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。用了AJAX之后，你点击，然后页面上的一行字就变化了，页面本身不用刷。 无关Cookie跨域Ajax请求服务器端通过在响应的 header 中设置 Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略。 示例123456//允许所有response.setHeader("Access-Control-Allow-Origin", "*");//允许特定if(request.getHeader("Origin").contains("mydomain.com")) &#123; response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));&#125; spring boot 通过配置文件实现1234567891011121314151617181920212223/*** 跨域请求配置* 可以单独作为一个配置文件类，也可以直接放在spring boot的启动类中*/@Configurationpublic class CorsConfig &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); //允许跨域携带cookie corsConfiguration.setAllowCredentials(true); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); return new CorsFilter(source); &#125;&#125; 带Cookie的跨域Ajax请求如果这些GET或POST请求不需要传递Cookie数据的话，就没什么问题了，但如果需要，那么会发现 虽然已经处理了跨域请求的问题，但后台始终无法获取到Cookie。跨域传输Cookie是需要后台和前台同时做相关处理才能解决的。 前端代码angularjs配置方法 angularjs1234567891011//单独配置$http.post("http://a.domain.com/Api/Product", &#123; productId: 3 &#125;, &#123; withCredentials: true, params: &#123; name: "Ray" &#125;&#125;).success(function (data) &#123; //TODO&#125;);//全局配置angular.module("app").config(function ($httpProvider) &#123; $httpProvider.defaults.withCredentials = true;&#125;) jquery配置方法 jquery12345678910111213$.ajax(&#123; type: "POST", url: "http://a.domain.com/Api/Product", xhrFields: &#123; withCredentials: true &#125;, success: function (data) &#123; console.log(data) &#125;, error: function (data) &#123; console.error(data) &#125;&#125;) 后端代码对应客户端的 xhrFields.withCredentials: true 参数，服务器端通过在响应 header 中设置 Access-Control-Allow-Credentials = true 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie。这里需要注意的是： 服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 ‘*’ 123456789101112/*** Spring Controller中的方法：*/ @RequestMapping(value = "/corsrequest") @ResponseBody public Map&lt;String, Object&gt; getUserBaseInfo(HttpServletResponse response) &#123; if(request.getHeader("Origin").contains("woego.cn")) &#123; response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin")); &#125; response.setHeader("Access-Control-Allow-Credentials", "true"); ...&#125; 另一种方式，在一个没有response参数的全局代码中： 123456HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder .getRequestAttributes()).getRequest();HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder .getRequestAttributes()).getResponse();//改写允许访问的域名地址为真实地址，解决跨域请求携带cookie问题response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin")); 参考资料Angularjs之如何在跨域请求中传输Cookie跨域Ajax请求时是否带Cookie的设置]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rockman]]></title>
    <url>%2Ftech%2Frockman%2F</url>
    <content type="text"><![CDATA[https://rockman.app/ 通过您网站访客的计算机挖取数字货币，不被广告拦截软件拦截。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>比特币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scriptbot脚本批处理程序开发]]></title>
    <url>%2Fcode%2Fscriptbot%2F</url>
    <content type="text"><![CDATA[ScriptBot 是一个采用sring boot框架开发的 脚本批处理工具，是博主开发的一个简单的自用工具本文意在通过该项目来总结一些Spring boot的web项目的开发经验 相关文章 参考资料 前端开发零碎TIPS cookie必须设置过期时间，cookie如果再没有设置期限的条件下如果关闭本浏览器就会自动的清除掉了cookie的值了。 如何让div成为背景层 12&lt;div style="position:absolute;z-index:-1;width: 100%;height: 100%" &gt;&lt;/div&gt; 判断一个变量是否存在，如果没有就给他一个初始值 123456var attr = attr || "";function Foo(option) &#123; var defaultValue = option || &#123;&#125;;&#125;Foo(); AngularJS路由系列(2)–刷新、查看路由,路由事件和URL格式，获取路由参数，路由的Resolve 刷新当前路由页面12345678910111213//刷新当前路由页面(function()&#123; angular.module('app') .controller('HomeController',['dataService','notifier', '$route', '$log', HomeController]); function HomeController(dataService, notifier, $route, $log)&#123; var vm = this; vm.message = 'Welcome to School Buddy!'; //重新刷新路由 vm.refresh = function()&#123; $route.reload(); &#125; &#125;&#125;());]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>scriptbot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习之路]]></title>
    <url>%2Fcode%2Fvue%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[遇到的问题参考 webpack学习webpack打包在控制台不能获取变量 - 穗乃果的回答 - SegmentFault 思否 技巧懒加载参考 webpack学习vue中的懒加载-Lazy Loading in Vue using Webpack’s Code Splitting懒加载 | webpack 中文网 vuexVuex | Vuex 是什么？]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scriptbot脚本批处理程序开发 - 参考资料]]></title>
    <url>%2Fcode%2Fscriptbot-refer%2F</url>
    <content type="text"><![CDATA[本文是scriptbot项目开发中的参考资料 相关文章scriptbot脚本批处理程序开发 cookie的path值的默认规则当cookie的path设置了值不为null的时候，以设置的值为准。当cookie的path为null时候，获取请求的URI的path值当URI的path值是以“/”结尾的时候，直接设置为cookie的path值当URI的path值不是以“/”结尾的时候，查看path里面是否有“/”如果有“/”的话，直接截取到最后一个“/”，然后设置为cookie的path值。如果没有“/”的话，将cookie的path设置为”/”。 前端零碎_.debounce_.debounce 用于限制函数的访问频率，在Underscore和loadash库中均有。浅谈 Underscore.js 中 _.throttle 和 _.debounce 1234567891011121314151617181920&lt;!-- 一个在vue中监控变量值变化的例子 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/underscore.js/1.9.0/underscore-min.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;input v-model="question"&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; question: "" &#125;);var log=_.debounce(function () &#123; console.log("changed"); &#125;,500);vm.$watch('question', function() &#123; console.log('wating'); log();&#125;);&lt;/script&gt; js中的箭头函数和匿名函数：以this为例子，对于普通函数（包括匿名函数），this指的是直接的调用者，在非严格模式下，如果没有直接调用者，this指的是window。箭头函数是没有自己的this，在它内部使用的this是由它定义的宿主对象决定。Vue实例里this的使用 不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 vue官方文档cn.vuejs.org/v2/guide/instance.html#实例生命周期钩子 跨域请求 携带cookieAngularjs之如何在跨域请求中传输Cookie跨域Ajax请求时是否带Cookie的设置 - CSDN博客解决cookie跨域访问 - 小眼儿 - 博客园服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 ‘*’ js css 前端特效动画特效站点网页特效库-html5 css3动画-banner特效-jquery特效代码CircularProgressButtonTutorialzine Shape Shifter-文字粒子特效-支持各种命令的粒子特效 impress.js 可以制作出类似prezi.com中的一张大图的幻灯片效果impress/impress.js 前端工具资料入门Webpack，看这篇就够了入门 Webpack，看这篇就够了 - 前端学习笔记 - SegmentFault 思否 node , 是javascript语言的环境和平台， npm , bower, yarn 是一类，包管理， webpack , browserify , rollup是一类，javascript模块打包方案(方案+工具+插件)， babel , 编译(compiler)下一代的ES语法的插件- requirejs , seajs , 是一类, 基于commonjs，amd，cmd，umd 之类的模块类包加载方案的框架， grunt , gulp , 前端工具，结合插件，合并、压缩、编译 sass/less，browser 自动载入资源， react , angular , vue , backbone , 是一类，mvc , mvvm , mvp 之类的前端框架， jquery , zepto , prototype , 是一类，前端 DOM , BOM 类库 ， ext , yui , kissy , dojo , 是一类，前端应用组件， lodash , underscore , 函数式编程库。 来源：https://www.zhihu.com/question/37694275/answer/113609266 后端Spring boot 定时任务SpringBoot定时任务及Cron表达式详解 fixedDelay和fixedRate区别：fixedDelay 在上一次执行结束后，等待xx毫秒后执行下一次fixedRate 每间隔xx毫秒执行下一次任务，如果到了下一个任务执行的时间但是上一个任务还未结束，那么上一个任务结束后立即执行该次任务。 crontab表达式1234567891011121314// spring的 表达式与linux的有所不同秒：可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数分：可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数时：可出现&quot;, - * /&quot;四个字符，有效范围为0-23的整数每月第几天：可出现&quot;, - * / ? L W C&quot;八个字符，有效范围为0-31的整数月：可出现&quot;, - * /&quot;四个字符，有效范围为1-12的整数或JAN-DEC星期：可出现&quot;, - * / ? L C #&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推&quot;0 0 * * * *&quot; 表示每小时0分0秒执行一次&quot; */10 * * * * *&quot; 表示每10秒执行一次&quot;0 0 8-10 * * *&quot; 表示每天8，9，10点执行&quot;0 0/30 8-10 * * *&quot; 表示每天8点到10点，每半小时执行&quot;0 0 9-17 * * MON-FRI&quot; 表示每周一至周五，9点到17点的0分0秒执行&quot;0 0 0 25 12 ?&quot; 表示每年圣诞节（12月25日）0时0分0秒执行]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>scriptbot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧妙的借助git快速批量转换crlf到lf]]></title>
    <url>%2Ftech%2F%E8%BD%AC%E6%8D%A2crlf%E5%88%B0lf%2F</url>
    <content type="text"><![CDATA[在windows和unix协同工作中，会遇到文件的换行符格式不一致的问题，windows采用的是crlf格式而unix采用的则是lf格式。日常中大家使用git协同办公是没有问题的，这是因为git会转换这两种格式，所以如果遇到需要批量修改文件的编码格式问题时，可以借助git快速修改 autocrlf是git的一个配置git config core.autocrlf autocrlf =true 表示要求git在提交时将crlf转换为lf，而在检出时将crlf转换为lfautocrlf = false表示提交和检出代码时均不进行转换autocrlf = input 表示在提交时将crlf转换为lf，而检出时不转换 因此我们只需要把需要转换的文件放入到一个文件夹里(work)，然后执行如下命令 1234567cd $workgit initgit add .git commit -m "init"#删除所有文件，然后从git检出rm -rf *git reset --hard HEAD 就可以简单呢转换crlf到lf了。是不是很巧妙的方式]]></content>
      <categories>
        <category>tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重写 spring boot 的邮件通知服务]]></title>
    <url>%2Fcode%2Fspring-boot-mail-notify%2F</url>
    <content type="text"><![CDATA[原理在org.springframework.mail.javamail包下的JavaMailSenderImpl类实现了邮件发送功能，查阅该类的配置文件代码可以看到JavaMailSenderImpl的配置类中启用了@ConditionalOnMissingBean(MailSender.class)这个注解，所以只要重新写代码实现MailSender接口并实例化，系统就不会再实例化JavaMailSenderImpl，便实现了替代原有的邮件发送 package org.springframework.boot.autoconfigure.mail12345678910111213141516171819202122232425262728293031@Configuration@ConditionalOnClass(&#123; MimeMessage.class, MimeType.class &#125;)@ConditionalOnMissingBean(MailSender.class)@Conditional(MailSenderCondition.class)@EnableConfigurationProperties(MailProperties.class)@Import(JndiSessionConfiguration.class)public class MailSenderAutoConfiguration &#123; private final MailProperties properties; private final Session session; public MailSenderAutoConfiguration(MailProperties properties, ObjectProvider&lt;Session&gt; session) &#123; this.properties = properties; this.session = session.getIfAvailable(); &#125; @Bean public JavaMailSenderImpl mailSender() &#123; JavaMailSenderImpl sender = new JavaMailSenderImpl(); if (this.session != null) &#123; sender.setSession(this.session); &#125; else &#123; applyProperties(sender); &#125; return sender; &#125; //....省略代码&#125; 实现以下是具体的实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.google.gson.Gson;import jodd.http.HttpRequest;import jodd.http.HttpResponse;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.MailSender;import org.springframework.mail.SimpleMailMessage;import org.springframework.stereotype.Component;@Componentpublic class EmailSender implements MailSender &#123; private final static Logger LOGGER = LoggerFactory.getLogger(EmailSender.class); @Value("$&#123;mail.server.url&#125;") private String EMAIL_SERVER_URL; @Override public void send(SimpleMailMessage simpleMailMessage)&#123; this.send(new SimpleMailMessage[]&#123;simpleMailMessage&#125;); &#125; @Override public void send(SimpleMailMessage... simpleMailMessages)&#123; for (SimpleMailMessage simpleMailMessage : simpleMailMessages) &#123; String to = StringUtils.join(simpleMailMessage.getTo(), ","); String cc = StringUtils.join(simpleMailMessage.getCc(), ","); String subject = simpleMailMessage.getSubject(); String body = simpleMailMessage.getText(); doSend(to, cc, subject, body); &#125; &#125; public void doSend(String receiver, String ccAddress, String subject, String body) &#123; Email email = new Email(receiver, ccAddress, subject, body); LOGGER.info(String.format("Send-Email-Request: [url=%s, to=%s, subject=%s, body=%s]", EMAIL_SERVER_URL, email.receiver, email.subject, email.body)); HttpRequest request = HttpRequest.post(EMAIL_SERVER_URL).multipart(true); HttpResponse response = request .form("sendEmailInfo", new Gson().toJson(email)).timeout(5000).send(); LOGGER.info(String.format("Send-Email-Response: [response=%s]", response.bodyText())); &#125; @Getter @Setter @AllArgsConstructor public static class Email &#123; private String receiver; private String ccAddress; private String subject; private String body; &#125;&#125;]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Awesome系列]]></title>
    <url>%2Fshare%2Fawesome-series%2F</url>
    <content type="text"><![CDATA[App Awesome App Awesomesource appAwesome 加载中(https://raw.githubusercontent.com/othorizon/MacAwesome/master/app.md) let xmlHttpRequest; function createXmlHttpRequest() { if (window.ActiveXObject) { //如果是IE浏览器 return new ActiveXObject("Microsoft.XMLHTTP"); } else if (window.XMLHttpRequest) { //非IE浏览器 return new XMLHttpRequest(); } } function loadData(url,callback) { xmlHttpRequest = createXmlHttpRequest(); xmlHttpRequest.onreadystatechange = callback; xmlHttpRequest.open("GET", url, true); xmlHttpRequest.send(null); } function loadComplete(elementId) { if (xmlHttpRequest.readyState == 4) {// 4 = "loaded" if (xmlHttpRequest.status == 200) {// 200 = OK document.getElementById(elementId).innerHTML = markdown.toHTML(xmlHttpRequest.responseText); } else { document.getElementById(elementId).innerHTML += " #加载失败"; } } } let appAwesomeUrl="https://raw.githubusercontent.com/othorizon/MacAwesome/master/app.md"; // load app awesome loadData(appAwesomeUrl,function(){ loadComplete("appAwesome") });]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>app推荐</tag>
        <tag>awesome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程之路]]></title>
    <url>%2Fcode%2Fjava%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[站外资料 断言的使用 [改善Java代码]断言绝对不是鸡肋]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 之路]]></title>
    <url>%2Fcode%2Fidea%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[新特性 2018.1 debug模式模拟抛出异常 http请求工具 其他特性 idea是博主最爱没有之一的开发工具，应该说jetbrains的开发工具都是非常棒的，idea的新特性在不停的增加，每次阅读更新日志都是一种享受像发现了新的玩具，2018年4月23这一天，本人决定开始记录idea使用过程中一些有价值的东西有些更新的特性可能不是严格按照idea本身的版本来编排的，主要是按照博主本人发现这个特性的时间来编写,文档从2018年4月23开始编写，会逐步补充该时间之前的一些内容 技巧@NotNull AnnotationsAnnotating Source Code - Help | IntelliJ IDEA idea有一个annotation.jar提供了一些有帮助的注解，其中包括了@NotNull检查的注解,该注解与lombok的@NonNull注解类似，会在编译代码时增加一个空指针检查，但是比lombok好的地方在于配合idea开发工具，会直接在开发界面提示空指针错误，以及在inspect code时提示可能的bug 如图所示，idea的非空注解会有inspection的提示执行Analyze-&gt;Inspect Code后也会得到bug提示 新特性2018.1 IntelliJ IDEA 2018.1.1 (Ultimate Edition)Build #IU-181.4445.78, built on April 10, 2018macOS 10.13.4 What’s New in IntelliJ IDEA debug模式模拟抛出异常可以在debug的断点位置模拟异常抛出，很实用 Throw ExceptionIntelliJ IDEA 2018.1 has a new Throw Exception action that allows you to throw an exception from a certain location in your program without changing the code. It is available from the Run | Throw Exception menu, or from the frame context menu during a debugging session. http请求工具可以直接将@RequestMapping和@GetMapping注解的方法生成http请求可以查阅示例文件(Tools|HTTP Client|Open HTTP Requests Collection)HTTP Client in IntelliJ IDEA Code Editor - Help | IntelliJ IDEAAccess HTTP request mappings from the editor via the new REST clientNow, after you run a Spring Boot web application, a new icon is shown in the gutter for methods with @RequestMapping annotations that handle incoming HTTP requests. Click this gutter icon to open all the mappings in a scratch file with an .http extension and perform an HTTP request in the editor via the new REST client. For methods with @GetMapping annotations, you have the choice to open the mapped URLs in a browser, or open a request in the HTTP Request Editor. Note, that you need to add the dependency for the spring-boot-starter-actuator to your pom.xml or build.gradle file. 其他特性代码可以按行提交了(git add -p)]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 学习之路]]></title>
    <url>%2Fcode%2Fjs%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[札记js中(function(){…})()立即执行函数写法理解js中(function(){…})()立即执行函数写法理解 - 生活还是要继续 - 博客园]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速打开页面的快照-快速打开页面的谷歌缓存]]></title>
    <url>%2Ftech%2Fgoogle-cache-md%2F</url>
    <content type="text"><![CDATA[google搜索关键词cache:[URL] 可以快速打开该URL的缓存快照]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决dns污染导致域名解析失败]]></title>
    <url>%2Ftech%2Fdns-host%2F</url>
    <content type="text"><![CDATA[打开http://ping.chinaz.com/gist.github.com输入希望解析的域名，比如gist.github.com,然后ping检测检测结束后按照响应时间排序找一个有效的ip配置host /etc/hosts12192.30.253.118 http://gist.github.com192.30.253.119 http://gist.github.com]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moco-超简单mock接口服务]]></title>
    <url>%2Fcode%2Fmoco%2F</url>
    <content type="text"><![CDATA[何谓mock接口mock接口就是模拟接口的意思。做开发中mock接口是经常需要的，服务直接依赖接口，而在开发中往往不适合或者无法直接调用对方的接口，这时候可以写一个假的接口，当这个接口被请求后直接返回事先设定的数据。 可以做mock的方法非常多，这里介绍一个非常简单小巧的命令行工具moco，其实就是一个jar包 moco官网：https://github.com/dreamhead/moco独立jar包下载地址：：Standalone Moco Runner Download（v 0.11.1) 简单使用 （Standalone Moco Runner）Qucik Start 官方说明 启动java -jar moco-runner-&lt;version&gt;-standalone.jar http -p 12306 -s 22306 -c setting.json-p启动端口-sshutdown端口，可以不指定，会默认分配。 shutdown的命令java -jar moco-runner-&lt;version&gt;-standalone.jar shutdown -s 22306-c配置文件 配置更多的配置方法可以看官方文档介绍 HTTP(s) APIs setting.json123456789101112131415161718192021222324252627[ &#123; "request": &#123; "uri": "/json", "method" : "post" //如果不指定method则get、post均可以 &#125;, "response": &#123; "json": //json格式返回值 &#123; "foo" : "bar" &#125; &#125; &#125;, &#123; "request": &#123; "uri": "/text", "method" : "get" &#125;, "response": &#123; "text" : "bar" //text格式返回值 &#125; &#125;] 实际使用的示例1234567891011121314$ tree.├── foo.json├── log.log├── moco-runner-0.11.1-standalone.jar├── settings.json├── shutdown.sh└── start.sh$ cat start.shjava -jar moco-runner-0.11.1-standalone.jar http -p 8100 -s 8101 -c settings.json &gt; log.log &amp;$ cat shutdown.shjava -jar moco-runner-0.11.1-standalone.jar shutdown -s 8101 settings.json12345678910111213141516171819202122232425[ &#123; "request": &#123; "uri": "/activiti/thrid/calApi" &#125;, "response": &#123; "json": &#123; "code": 200, "message": "模拟计费成功" &#125; &#125; &#125;, &#123; "request": &#123; "uri": "/api/bossConvertAll" &#125;, "response": &#123; "json": &#123; "code": 200, "message": "转换成功", "requestId": "cg2uAs3P" &#125; &#125; &#125;] foo.json12345678[ &#123; "response" : &#123; "text" : "foo" &#125; &#125;]]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器配置ss代理-极路由安装ss代理-ps4配置ss代理-ps4堡垒之夜ss代理]]></title>
    <url>%2Ftech%2Fss-hiwifi-ps4%2F</url>
    <content type="text"><![CDATA[本文将介绍如何给“极路由”配置ss代理，以实现ps4通过代理来游玩“堡垒之夜”等游戏，当然除了玩游戏自然也是可以用来科学上网 ps4加速/代理 的几种方式 购买主机游戏加速服务，比如“奇游”加速，这是最简单的方案，适合纯小白，具体如何配置官网也有介绍，不再赘述 借助电脑与主机在同一局域网的电脑来给主机提供代理服务 路由器安装ss代理本文讲述的就是这个方案 因为主机不能安装第三方服务，所以主机加速方案其实都一样，就是借助路由器或者其他代理服务 具体步骤温馨提示：请学会享受DIY的乐趣，给自己一些时间与耐心，以及必不可少的自信。不要害怕麻烦，遇到问题，查资料询问他人或博主解决就好了 step1: 极路由安装ss代理step1.1:申请开发者模式，开启root权限 登陆极路由管理后台，进入“云插件”，然后依次点击“已安装的插件》路由器信息》高级设置》申请，按照提示操作就好了开发者模式会失去保修，开发者模式可以让你通过ssh登陆路由器的服务器进行一些列root权限的操作 申请成功后，回到云插件下载页，会多出一些插件来，其中包括一个“开发者模式“，安装这个插件 step1.2:安装ss插件博主看到的目前极路由的ss插件有一两款，博主使用的是这个qiwihui/hiwifi-ss对github以及代码有了解，打开看一下就知道怎么安装了具体步骤如下： 首先登陆极路由的服务器，mac或linux用户ssh登陆就好了，如果Windows用户可以下载xshell来登陆“xshell”官网是提供免费版的，如果官网看不明白也可以百度下载一个然后安装就好了 使用“xshell”或者终端输入命令ssh root@192.168.199.1 -p 1022登陆后台,如果报错可以试下ssh root@192.168.199.1 1022登陆密码就是你的路由器后台管理页面的登陆密码（不是wifi密码）,登陆成功如图 登陆之后输入以下命令执行,这个是安装ss服务的 1cd /tmp &amp;&amp; curl -k -o shadow.sh https://raw.githubusercontent.com/qiwihui/hiwifi-ss/master/shadow.sh &amp;&amp; sh shadow.sh &amp;&amp; rm shadow.sh (插件官网说明)如果需要卸载就将/usr/lib/lua/luci/view/admin_web/network/index.htm.ssbak 重命名为 /usr/lib/lua/luci/view/admin_web/network/index.htm, 并移除ss: opkg remove geewan-ss 路由器的固件升级，或者恢复出厂设置可能会导致插件被删除，可以把路由器升级方式设置为手动 step2: 配置ss插件按步骤1安装好之后，重启路由器，登陆路由器后台之后，会看到多了一个“安全上网”的设置，打开填入ss的配置就好了ss可以通过购买，或者自己搭建ss服务两种方式，不是本文重点不在这里做介绍了，注意区分ss和ssr，ssr可以兼容ss，但是ss是无法使用ssr的配置好后如果显示“连接正常”就说明是ok的，这时候打开网页试试能不能连通世界了，或者打开ip.cn看看ip地址是不是外面的ip 以上都ok的话，那么恭喜你，你已经可以向世界说“hello world”了，但是如果你还想游玩“堡垒之夜”那么你还需要一步 step3: 配置dnsmasq这里是重点了，博主为了玩到“堡垒之夜”折腾了好久，最后却发现还是不能玩，其实原因很简单，正如之前在ss设置中选择的“智能模式”，这句话的意思就是根据ip自动选择是否采用代理访问，很明显“堡垒之夜”的服务器不在此范畴并没有走代理，所以需要自己配置一下。有两种办法 复杂与简单的，自己选咯 简单的方式在ss的设置里，运行模式选择“全局模式”，这样所有的网络请求都会走代理，就是说上个百度也是走的代理（打开百度搜索“ip”你会发现ip地址变了），如果不想这样就用复杂模式吧 复杂的方式堡垒之夜的服务器域名应该是datarouter.ol.epicgames.com和lightswitch-public-service-prod06.ol.epicgames.com这两个，也是猜测没有具体验证，所以为了方便我们就直接匹配顶级域名就好了，就用epicgames.com简单利索，代理epicgames的所有地址 登陆极路由服务器，还记得方法吧ssh root@192.168.199.1 -p 1022 输入vi /etc/gw-shadowsocks/gw-shadowsocks.dnslist 1root@Hiwifi:~# vi /etc/gw-shadowsocks/gw-shadowsocks.dnslist 然后在配置里增加一行配置server=/epicgames.com/127.0.0.1#53535 vi是一个文本编辑器，输入上面命令回车后会打开一个文件进行编辑，先按下键盘的a键开启编辑操作，然后这时候就可以输入文本了，输入结束后按下esc键结束编辑，然后输入:wq这时候会保存并退出 /etc/gw-shadowsocks/gw-shadowsocks.dnslist1234567# dnsmasq rules generated by gfwlist# Last Updated on 2017-08-08 11:36:59##+server=/epicgames.com/127.0.0.1#53535server-/030buy.com/127.0.0 1#53535server=/0rz.tw/127.0.0.1#53535 恭喜，至此就大功告成了，打开游戏看一下是不是可以进入了 有什么问题可以留言咨询，留言时输入邮箱可以收到回复通知祝你玩的开心 have a nice day～]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>ps4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客改造]]></title>
    <url>%2Ftech%2Fhexo%E6%94%B9%E9%80%A0%2F</url>
    <content type="text"><![CDATA[修改首页摘要中的锚链接可直接跳转到正文 hexo博客相关其他文章 修改首页摘要中的锚链接可直接跳转到正文背景博主喜欢把“table of content”即目录放到&lt;!-- more --&gt;标签前面作为文章在首页的一个摘要，简洁明了可辨识，并且博主使用VSCode写文，有插件可以直接生成TOC因此非常方便问题但是因为TOC都是锚链接因此在首页的链接是无法跳转到正文的简单的解决办法就是把TOC的链接地址改为绝对路径的引用 123[章节1](#章节1)修改为[章节1](/post/文章/章节1) 但是这样引入的问题就是，在正文中点击文章中的TOC链接会重新打开页面解决方案这里就是正文了，思路就是修改themes/next/layout/_macro/post.swig这个文件，这个文件是用来做首页的一系列处理的 themes/next/layout/_macro/post.swig123456789&#123;% if is_index %&#125;...(忽略一段)&#123;% elif post.excerpt %&#125;- &#123;&#123; post.excerpt &#125;&#125;+ &#123;&#123; post.excerpt|replace('href="#','href="'+url_for(post.path)+'#','ig') &#125;&#125;&#125;&lt;!--noindex--&gt;&lt;div class="post-button text-center"&gt;&lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __('post.more') &#125;&#125;&#123;% endif %&#125;" rel="contents"&gt; 效果可以直接返回博客首页看本文的摘要解释加了一个replace过滤器对摘要内容替换链接地址，markdown文章解析到首页后是html格式的 在post.swig文件的if is_index的代码块内是根据各种条件来生成摘要，这里只对通过&lt;!-- more --&gt;分割形成的摘要做了处理，其他的并没有处理 1234上述的toc链接解析后如下&lt;a href="#章节1"&gt;章节1&lt;/a&gt;replace后替换为&lt;a href="/post/文章#章节1"&gt;章节1&lt;/a&gt; 相关知识swing的replace第一个参数是被替换的文本，支持正则匹配，第二个是要替换成的问题，第三个可选参数是匹配类型，如果不写则只会替换一个文本i：ignorCase忽略大小写m：mutiple允许多行匹配g：globle进行全局匹配，指匹配到目标串的结尾replace(search, replacement[, flags]) Name Type Optional Default Description search string undefined String or pattern to replace from the input. replacement string undefined String to replace matched pattern. flags string ✔ undefined Regular Expression flags. ‘g’: global match, ‘i’: ignore case, ‘m’: match over multiple lines Swig Documentation,Filters#replace 潜在的问题不做任何判断的直接replace链接是不严谨的，有可能会替换掉并不应该替换的链接 博主对swig语法一点不懂，全靠直觉暴力写了这个东西，逻辑上并不严谨，但是怎奈因为swig不熟没法写复杂的逻辑，如有哪位大神懂还望指点一二 hexo博客相关其他文章 hexo优化]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客-hexo博客]]></title>
    <url>%2Ftech%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[1、在source文件夹中新建一个CNAME文件（无后缀名），然后用文本编辑器打开，在首行添加你的网站域名，如http://xxxx.com，注意前面没有http://，也没有www，然后使用hexo g &amp;&amp; hexo d上传部署。2、在域名解析提供商，下面以dnspod为例。（1）先添加一个CNAME，主机记录写@，后面记录值写上你的http://xxxx.github.io（2）再添加一个CNAME，主机记录写www，后面记录值也是http://xxxx.github.io这样别人用www和不用www都能访问你的网站（其实www的方式，会先解析成http://xxxx.github.io，然后根据CNAME再变成http://xxx.com，即中间是经过一次转换的）。上面，我们用的是CNAME别名记录，也有人使用A记录，后面的记录值是写github page里面的ip地址，但有时候IP地址会更改，导致最后解析不正确，所以还是推荐用CNAME别名记录要好些，不建议用IP。3、等十分钟左右，刷新浏览器，用你自己域名访问下试试 作者：skycrown链接：https://www.zhihu.com/question/31377141/answer/87541858来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo优化]]></title>
    <url>%2Ftech%2Fhexo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTTP vs HTTPS 对SEO的影响 加载速度 图片格式选择与压缩图片 压缩图片是最简单的方法，在线图片压缩 选择一个合适的图片格式 细节调整 markdown渲染时锚点链接大小写问题 HTTP vs HTTPS 对SEO的影响百度搜索引擎认为权值相同的站点，采用https协议的页面更加安全，排名上会优先对待 百度站长百度开放收录https站点公告 HTTP vs HTTPS 对SEO的影响？ - 知乎 加载速度参考：免费CDN和网站速度测试工具 CDN:jsdelivr 前端公共库CDN加速服务 图片格式选择与压缩图片除了使用图床之外，有时候也有一些站内的图片，比如avatar头像等，选择一个合适的图片格式尽可能的减小图片体积。 压缩图片是最简单的方法，在线图片压缩图好快 :国内，支持很丰富的场景和格式，收费TinyPNG:国外，可以压缩png和jpg格式图片，免费 选择一个合适的图片格式jpg gif png格式比较与简单描述： 格式 描述 如何选 gif 全称JPEG，具有较高的压缩率，有损压缩格式，可以指定压缩的百分比，方便把控图片尺寸和质量的比例，不支持透明格式 支持动画效果，提交较小 jpg 有静态gif和动态gif，体积小，早期网速较慢时使用很流行 可以保留图片更多的色彩细节，对于色彩丰富的图片推荐使用 png 为了取代git和jpg而诞生的格式，与gif比支持更丰富的透明度（gif只有透明与不透明），与png比可以在保留图片所有细节的前提下实现高压缩比的图片压缩，是无损压缩 支持透明，对于一些色彩简单的，纯色块较多的图片推荐使用 总结：选择什么格式自己试一下就好了，博主为了尽量在保证质量的情况下减少本博客的avatar(头像)的大小，可以说是各种格式的图片不同的压缩比都反复尝试了，来回对比之后终于选定了一个“中等压缩质量”的“jpg“图片 博主对图片没有太多涉猎,以上主要参考了横向对比GIF/JPEG/PNG/SVG，教你如何合理选择图像格式一文，以及结合了一些自己的理解。 细节调整markdown渲染时锚点链接大小写问题以下是hexo-renderer-marked插件的README说明，其中modifyAnchors设置用于将markdown的标题转为锚点链接时大小写问题，一般来说id字段我们都是用小写配置，这样对其他程序兼容性更好些，因此推荐设置为1,默认是不改变大小写 You can configure this plugin in _config.yml. 12345678910marked: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: true modifyAnchors: '' autolink: true gfm - Enables GitHub flavored markdown pedantic - Conform to obscure parts of markdown.pl as much as possible. Don’t fix any of the original markdown bugs or poor behavior. sanitize - Sanitize the output. Ignore any HTML that has been input. tables - Enable GFM tables. This option requires the gfm option to be true. breaks - Enable GFM line breaks. This option requires the gfm option to be true. smartLists - Use smarter list behavior than the original markdown. smartypants - Use “smart” typograhic punctuation for things like quotes and dashes. modifyAnchors - Use for transform anchorIds. if 1 to lowerCase and if 2 to upperCase. autolink - Enable autolink for URLs. E.g. https://hexo.io will become &lt;a href=&quot;https://hexo.io&quot;&gt;https://hexo.io&lt;/a&gt;.]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图床]]></title>
    <url>%2Fshare%2F%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[mac图床工具推荐UPImageMacApp:支持自动上传，粘贴方便github地址:UPImageMacApp介绍:U图床一款Mac小软件（用于上传图片到图床生成外链接(支持生成markdown链接)） fu:不支持自动传支持图片水印支持图片压缩支持多种上传方式github地址:fu介绍:开源跨平台图床上传工具（暂时只实现 Mac OS 版本） - V2EX]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习历程]]></title>
    <url>%2Froad%2F</url>
    <content type="text"><![CDATA[历程 学习 Cocos Creator，并尝试开发微信小游戏 搭建gitbook 学习npm并开发gitbook的插件 学习 spring cloud 微服务架构 2018.02 搭建hexo博客并调整代码实现客制化需求 2018.03 开发hexo的插件满足客制化需求 开发 scriptbot 脚本批处理程序 2018.05.04 学习使用 Amaze UI 复习使用 AngularJS与jQuery 学习 Vue.js 学习webpack 2018.05.30 将scriptbot的前端angularjs框架换成vue框架 开始BI项目开发 2018.07.01 学习hive、hadoop(hdfs) 调研presto、kylin 整合spring cloud docker之路 深入学习docker并尝试应用docker在线上环境 2018.08.01]]></content>
  </entry>
  <entry>
    <title><![CDATA[picture-demo]]></title>
    <url>%2Fdemo%2Fpicture-demo%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git之路]]></title>
    <url>%2Fcode%2Fgit%2F</url>
    <content type="text"><![CDATA[git配置多个远程仓库 git的本地仓库和服务器仓库/裸库 git复制仓库 git配置多个远程仓库需求想要把项目同步备份到coding中一份，期望每次push代码时可以同步push到coding仓库中 解决方案 在git仓库根目录执行git remote add --mirror=push coding git@git.coding.net:example/example.git,添加一个镜像仓库，用来初始化镜像仓库数据或者pull镜像仓库数据时使用。对镜像仓库push数据时相当于执行git push --mirror，会强制覆盖仓库中的数据 ，会以镜像的方式把包括所有分支和历史的commit提交到目标仓库 执行 12git remote set-url origin --push --add git@git.coding.net:example/example.gitgit remote set-url origin --push --add git@github.com:example/example.git 一定要把两个都设置上:设置origin的pushurl为这两个远程仓库url，当设置了pushurl之后便不会再使用url作为默认的pushurl了，所以一定要把两个都设置上 第一次设置后先执行git push coding把origin的代码镜像到coding仓库 使用使用时修改文件之后只需要正常的执行git push便会向两个目标仓库都推送一遍。 git config1234567891011[remote &quot;origin&quot;] url = git@github.com:example/example.git fetch = +refs/heads/*:refs/remotes/origin/* pushurl = git@git.coding.net:example/example.git pushurl = git@github.com:example/example.git[branch &quot;master&quot;] remote = origin merge = refs/heads/master[remote &quot;coding&quot;] url = git@git.coding.net:example/example.git mirror = true 另外不推荐在镜像仓库修改文件，但是如果真的在镜像仓库修改了文件而需要同步到原始仓库，那么先git pull coding获取镜像仓库的最新代码，然后check out origin master ,然后在merge代码过来。具体可以借鉴Syncing a forkGitHub官网的fork代码同步的操作步骤， 参考git push如何至两个git仓库 - SegmentFault 思否准备更换git托管，如何迁移原git仓库 - SegmentFault 思否git本地仓库关联多个remote,怎么用本地一个分支向不同remote不同分支推送代码？ - 知乎 git的本地仓库和服务器仓库/裸库简单总结就是：不加--bare参数得到的仓库（无论是init还是clone操作），是一个包含工作空间的仓库，可以修改工作空间内容后提交。加--bare参数得到的是不包含工作空间的裸库，因此无法直接修改工作文件。一般是作为远端中心仓库或者说服务器仓库存在的。工作人员从该裸库clone到本地后进行工作然后提交到仓库。 参考：服务器上的 Git|git-scmGit 本地仓库和裸仓库 - TaoBeier - SegmentFault 思否搭建Git服务器 详解：通过 git init命令可以创建一个本地仓库本地仓库具备了git的版本控制，可以进行文件修改和commit仓库，如果git remote add origin [gitUrl]之后还可以push到远程仓库， 而通过git init --bare则是创建的一个裸库也可以理解为是服务器仓库，该仓库没有工作空间，也就是用户无法直接在该仓库编辑工作文件，只能通过clone下来后进行文件修改然后commit、push。所以git init --bare是创建一个git服务器的过程，git clone --bare [projectUrl] newProjectRepo则是克隆一个仓库作为新的服务器仓库/裸库（没有工作空间的仓库）的操作，测试git clone [projectUrl] newProject这样clone下来的是一个projectUrl的本地工作空间， git复制仓库Mirroring a repository Duplicating a repository - Github User Documentation1.Open Terminal.2.Create a bare clone of the repository. 1git clone --bare https://github.com/exampleuser/old-repository.git 3.Mirror-push to the new repository. 12cd old-repository.gitgit push --mirror https://github.com/exampleuser/new-repository.git 4.Remove the temporary local repository you created in step 1. 12cd ..rm -rf old-repository.git]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fdemo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[示例页面]]></title>
    <url>%2Fdemo%2Fexample%2F</url>
    <content type="text"><![CDATA[各种博客的写作方法demo hello world example11echo hello_world hello world example21echo hello_world 图片图片测试2 tag参考 Hexo+markdown优雅写博客 标签地平线上hello world authorrizon的博客地平线上hello world authorrizon.topblah blah blah success default info 内置标签 - NexT 使用文档 warning default primary success info warning danger 选项卡 1选项卡 2选项卡 3这是选项卡 1 哈哈哈 这是选项卡 2 这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～，哈哈哈哈哈哈哈哈，好无聊啊我…… 引用 123456qwertyu 表格 Column A Column B Column C A1 B1 C1 A2 B2 C2 A3 B3 C3 添加Meta信息摘选自:Hexo博客系列（四）：写作和图床 Hexo默认的文件头只有title、date、tags属性，生成的html会缺少Meta信息，不利于搜索引擎收录。建议自行在文件头中添加keywords和description属性。categories属性可自行选择是否添加。 文件头格式为： 12345678title: ##文章标题date: ##时间，格式为 YYYY-MM-DD HH:mm:sscategories: ##分类tags: ##标签，多标签格式为 [tag1,tag2,...]keywords: ##文章关键词，多关键词格式为 keyword1,keywords2,...description: ##文章描述---正文 例如12345678title: 这是一篇测试文章date: 2015-03-21 15:13:48categories: Hexotags: [Hexo,测试]keywords: Hexo,文章,测试description: 这是一篇测试文章，用于测试Hexo文章文件头。---正文 参考Next主题个性化之自动更换背景图片 - CSDN博客打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 【搜索优化】Hexo-next百度和谷歌搜索优化【转】Blog摘要配图 浅析静态博客程序的优点与不足Font Awesome望川秋酷Raincal’s Bloghexo的next主题个性化教程：打造炫酷网站hexo的next主题个性化教程:打造炫酷网站 使用Hexo基于GitHub Pages搭建个人博客（三） disqus代理/disqus-proxy-dockerbiueo/hexo_website_code/Hexo部分优化.md]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
</search>
